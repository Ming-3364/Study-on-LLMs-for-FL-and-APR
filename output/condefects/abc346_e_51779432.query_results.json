[
    {
        "prompt_fl_1": {
            "doubao-pro-4k": "9",
            "ernie-3.5-128k": "22",
            "qwen-turbo": "24",
            "deepseek-chat": "18",
            "gpt-4o-mini": "26"
        },
        "prompt_fl_4": {
            "qwen-turbo": "map.put(0,map.getOrDefault(0,0l)+W*H);",
            "doubao-pro-4k": "int[] T=new int[M],A=new int[M],X=new int[M];",
            "deepseek-chat": "map.put(x,map.getOrDefault(x,0l)+W);",
            "ernie-3.5-128k": "map.put(x, map.getOrDefault(x, 0l) + (t == 1 ? W : H));",
            "gpt-4o-mini": "H--;"
        },
        "prompt_apr_1": {
            "deepseek-chat": "The bug in line 36 is related to the use of `0l` (the letter 'l' at the end) instead of `0L` (the letter 'L' at the end). In Java, the suffix `L` is used to denote a long literal, and using `l` (lowercase L) can be confusing because it looks similar to the number `1`. The corrected code should use `0L` instead of `0l`.\n\nHere is the complete corrected method:\n\npublic static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0L)+W*H);\n    \n    var colors=new java.util.ArrayList<Integer>();\n    for(var set:map.entrySet()){\n      if(set.getValue()>0)colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color:colors)System.out.println(color+\" \"+map.get(color));\n}",
            "qwen-turbo": "Certainly! The issue on line 36 seems to be related to the logic where you are putting the value `0` into the map. This could potentially overwrite other values or cause unexpected behavior. Instead, we should ensure that the initial value calculation is done correctly before the loop starts.\n\nHere's the complete corrected method:\n\n```java\npublic static void main(String[] args){\n    var sc = new java.util.Scanner(System.in);\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int M = sc.nextInt();\n    int[] T = new int[M], A = new int[M], X = new int[M];\n    \n    for(int i = 0; i < M; i++){\n      T[i] = sc.nextInt();\n      A[i] = sc.nextInt() - 1;\n      X[i] = sc.nextInt();\n    }\n    \n    var map = new java.util.HashMap<Integer, Long>();\n    boolean[] hused = new boolean[H], vused = new boolean[W];\n    \n    // Initialize the map with the initial area\n    map.put(0L, (long)H * W);\n    \n    for(int i = M - 1; i >= 0; i--){\n      int t = T[i];\n      int a = A[i];\n      int x = X[i];\n      \n      if(t == 1){\n        if(!hused[a]){\n          hused[a] = true;\n          map.put((long)x, map.getOrDefault((long)x, 0L) + W);\n          H--;\n        }\n      } else {\n        if(!vused[a]){\n          vused[a] = true;\n          map.put((long)x, map.getOrDefault((long)x, 0L) + H);\n          W--;\n        }\n      }\n    }\n    \n    var colors = new java.util.ArrayList<Integer>();\n    for(var entry : map.entrySet()){\n      if(entry.getValue() > 0) colors.add(entry.getKey().intValue());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color : colors) System.out.println(color + \" \" + map.get((long)color));\n}\n```\n\nIn this corrected version:\n- The map is initialized with the initial area before entering the loop.\n- The key type in the map is explicitly cast to `Long` to avoid potential issues with auto-boxing.\n- When adding values to the map inside the loop, keys are also cast to `Long`.\n- The final print statement now uses `entry.getKey().intValue()` to get the integer value of the key.",
            "gpt-4o-mini": "public static void main(String[] args){\n    var sc = new java.util.Scanner(System.in);\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int M = sc.nextInt();\n    int[] T = new int[M], A = new int[M], X = new int[M];\n    \n    for (int i = 0; i < M; i++) {\n        T[i] = sc.nextInt();\n        A[i] = sc.nextInt() - 1;\n        X[i] = sc.nextInt();\n    }\n    \n    var map = new java.util.HashMap<Integer, Long>();\n    boolean[] hused = new boolean[H], vused = new boolean[W];\n    \n    for (int i = M - 1; i >= 0; i--) {\n        int t = T[i];\n        int a = A[i];\n        int x = X[i];\n        \n        if (t == 1) {\n            if (!hused[a]) {\n                hused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + W);\n                H--;\n            }\n        } else {\n            if (!vused[a]) {\n                vused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + H);\n                W--;\n            }\n        }\n    }\n    \n    map.put(0, map.getOrDefault(0, 0L) + (long) W * H);\n    \n    var colors = new java.util.ArrayList<Integer>();\n    for (var set : map.entrySet()) {\n        if (set.getValue() > 0) colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for (int color : colors) System.out.println(color + \" \" + map.get(color));\n}",
            "doubao-pro-4k": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0L)+W*H);\n    \n    var colors=new java.util.ArrayList<Integer>();\n    for(var set:map.entrySet()){\n      if(set.getValue()>0)colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color:colors)System.out.println(color+\" \"+map.get(color));\n  }",
            "ernie-3.5-128k": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+W);  // Corrected: Changed '0l' to '0L' for long literal\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+H);  // Corrected: Changed '0l' to '0L' for long literal\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0L)+W*H);  // Corrected: Changed '0l' to '0L' for long literal\n    \n    var colors=new java.util.ArrayList<Integer>();\n    for(var set:map.entrySet()){\n      if(set.getValue()>0)colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color:colors)System.out.println(color+\" \"+map.get(color));\n  }"
        },
        "prompt_apr_2": {
            "gpt-4o-mini": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    // Fixing the bug here by checking map for 0 key\n    map.put(0, map.getOrDefault(0L, 0L) + (long)W * (long)H);\n    \n    var colors=new java.util.ArrayList<Integer>();\n    for(var set:map.entrySet()){\n      if(set.getValue()>0)colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color:colors)System.out.println(color+\" \"+map.get(color));\n}",
            "qwen-turbo": "Certainly! The issue with the line `map.put(0,map.getOrDefault(0,0l)+W*H);` is that it might be placing an initial value before processing all the operations, which could lead to incorrect results. Instead, you should place this logic after the loop where you process the operations to ensure that the map contains the correct values.\n\nHere is the complete corrected method:\n\n```java\npublic static void main(String[] args){\n    var sc = new java.util.Scanner(System.in);\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int M = sc.nextInt();\n    int[] T = new int[M], A = new int[M], X = new int[M];\n    \n    for(int i = 0; i < M; i++){\n      T[i] = sc.nextInt();\n      A[i] = sc.nextInt() - 1;\n      X[i] = sc.nextInt();\n    }\n    \n    var map = new java.util.HashMap<Integer,Long>();\n    boolean[] hused = new boolean[H], vused = new boolean[W];\n    \n    for(int i = M - 1; i >= 0; i--){\n      int t = T[i];\n      int a = A[i];\n      int x = X[i];\n      \n      if(t == 1){\n        if(!hused[a]){\n          hused[a] = true;\n          map.put(x, map.getOrDefault(x, 0l) + W);\n          H--;\n        }\n      } else {\n        if(!vused[a]){\n          vused[a] = true;\n          map.put(x, map.getOrDefault(x, 0l) + H);\n          W--;\n        }\n      }\n    }\n    \n    // Corrected placement of the initialization logic\n    long totalArea = (long) W * H;\n    for (var entry : map.entrySet()) {\n        totalArea -= entry.getValue();\n    }\n    map.put(0, map.getOrDefault(0L, 0L) + totalArea);\n\n    var colors = new java.util.ArrayList<Integer>();\n    for (var set : map.entrySet()) {\n        if (set.getValue() > 0) colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for (int color : colors) System.out.println(color + \" \" + map.get(color));\n}\n```\n\nThis ensures that the `totalArea` calculation is done correctly after processing all operations and then adds the remaining area to the map. This should resolve the issue you were facing.",
            "deepseek-chat": "The bug in the line `map.put(0,map.getOrDefault(0,0l)+W*H);` is that it incorrectly assumes that the remaining cells (after applying all operations) should be assigned the color `0`. However, this is not necessarily true because the remaining cells could have been affected by previous operations. Instead, we should calculate the remaining cells and assign them the color `0` only if they haven't been assigned any color yet.\n\nHere is the complete corrected method:\n\n```java\npublic static void main(String[] args){\n    var sc = new java.util.Scanner(System.in);\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int M = sc.nextInt();\n    int[] T = new int[M], A = new int[M], X = new int[M];\n    \n    for(int i = 0; i < M; i++){\n        T[i] = sc.nextInt();\n        A[i] = sc.nextInt() - 1;\n        X[i] = sc.nextInt();\n    }\n    \n    var map = new java.util.HashMap<Integer, Long>();\n    boolean[] hused = new boolean[H], vused = new boolean[W];\n    \n    for(int i = M - 1; i >= 0; i--){\n        int t = T[i];\n        int a = A[i];\n        int x = X[i];\n        \n        if(t == 1){\n            if(!hused[a]){\n                hused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + W);\n                H--;\n            }\n        } else {\n            if(!vused[a]){\n                vused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + H);\n                W--;\n            }\n        }\n    }\n    \n    // Calculate the remaining cells that haven't been assigned any color\n    long remainingCells = (long) H * W;\n    if (remainingCells > 0) {\n        map.put(0, map.getOrDefault(0, 0L) + remainingCells);\n    }\n    \n    var colors = new java.util.ArrayList<Integer>();\n    for(var set : map.entrySet()){\n        if(set.getValue() > 0) colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color : colors) System.out.println(color + \" \" + map.get(color));\n}\n```\n\n### Explanation of the Fix:\n- The line `map.put(0, map.getOrDefault(0, 0L) + W * H);` was replaced with a more accurate calculation of the remaining cells that haven't been assigned any color.\n- The remaining cells are calculated as `(long) H * W`, and if there are any remaining cells, they are assigned the color `0`.\n- This ensures that only the cells that haven't been affected by any row or column operations are assigned the color `0`.\n\nThis correction ensures that the final count of cells with color `0` is accurate and reflects the actual state of the grid after all operations have been applied.",
            "doubao-pro-4k": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0l)+(long)W*H); // Bug fixed here\n    \n    var colors=new java.util.ArrayList<Integer>();\n    for(var set:map.entrySet()){\n      if(set.getValue()>0)colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for(int color:colors)System.out.println(color+\" \"+map.get(color));\n  }",
            "ernie-3.5-128k": "public static void main(String[] args) {\n    var sc = new java.util.Scanner(System.in);\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int M = sc.nextInt();\n    int[] T = new int[M], A = new int[M], X = new int[M];\n    \n    for (int i = 0; i < M; i++) {\n        T[i] = sc.nextInt();\n        A[i] = sc.nextInt() - 1;\n        X[i] = sc.nextInt();\n    }\n    \n    var map = new java.util.HashMap<Integer, Long>();\n    boolean[] hused = new boolean[H], vused = new boolean[W];\n    \n    for (int i = M - 1; i >= 0; i--) {\n        int t = T[i];\n        int a = A[i];\n        int x = X[i];\n        \n        if (t == 1) {\n            if (!hused[a]) {\n                hused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + (W - vusedCount(vused, W)));\n                H--;\n                updateVused(vused, W, a, false);\n            }\n        } else {\n            if (!vused[a]) {\n                vused[a] = true;\n                map.put(x, map.getOrDefault(x, 0L) + (H - husedCount(hused, H)));\n                W--;\n                updateHused(hused, H, a, false);\n            }\n        }\n    }\n    \n    // Correcting the bug: Instead of adding W*H directly, we should consider the remaining unused areas\n    long totalUnused = (H - countTrue(hused)) * (W - countTrue(vused));\n    map.put(0, map.getOrDefault(0, 0L) + totalUnused);\n    \n    var colors = new java.util.ArrayList<Integer>();\n    for (var set : map.entrySet()) {\n        if (set.getValue() > 0) colors.add(set.getKey());\n    }\n    \n    java.util.Collections.sort(colors);\n    \n    System.out.println(colors.size());\n    for (int color : colors) System.out.println(color + \" \" + map.get(color));\n}\n\n// Helper methods to count used rows/columns and update the used status correctly\nprivate static int husedCount(boolean[] hused, int H) {\n    int count = 0;\n    for (boolean used : hused) {\n        if (used) count++;\n    }\n    return count;\n}\n\nprivate static int vusedCount(boolean[] vused, int W) {\n    int count = 0;\n    for (boolean used : vused) {\n        if (used) count++;\n    }\n    return count;\n}\n\nprivate static int countTrue(boolean[] array) {\n    int count = 0;\n    for (boolean value : array) {\n        if (value) count++;\n    }\n    return count;\n}\n\nprivate static void updateHused(boolean[] hused, int H, int index, boolean value) {\n    if (index >= 0 && index < H) {\n        hused[index] = value;\n    }\n}\n\nprivate static void updateVused(boolean[] vused, int W, int index, boolean value) {\n    if (index >= 0 && index < W) {\n        vused[index] = value;\n    }\n}\n\nNote: The provided solution includes helper methods to correctly count and update the used horizontal and vertical lines, as well as to fix the issue with the direct addition of `W*H` to the map. The logic now considers only the unused portions of the grid when calculating the total unused area."
        },
        "prompt_apr_3": {
            "qwen-turbo": "```java\npublic static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0L,map.getOrDefault(0L,0L)+W*H);\n```",
            "deepseek-chat": "```java\npublic static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0L)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0L)+(long)W*H);\n```",
            "gpt-4o-mini": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0l)+H*W);",
            "doubao-pro-4k": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    map.put(0,map.getOrDefault(0,0l)+(long)H*W);\n}",
            "ernie-3.5-128k": "public static void main(String[] args){\n    var sc=new java.util.Scanner(System.in);\n    int H=sc.nextInt();\n    int W=sc.nextInt();\n    int M=sc.nextInt();\n    int[] T=new int[M],A=new int[M],X=new int[M];\n    \n    for(int i=0;i<M;i++){\n      T[i]=sc.nextInt();\n      A[i]=sc.nextInt()-1;\n      X[i]=sc.nextInt();\n    }\n    \n    var map=new java.util.HashMap<Integer,Long>();\n    boolean[] hused=new boolean[H],vused=new boolean[W];\n    \n    for(int i=M-1;i>=0;i--){\n      int t=T[i];\n      int a=A[i];\n      int x=X[i];\n      \n      if(t==1){\n        if(!hused[a]){\n          hused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+W);\n          H--;\n        }\n      }else{\n        if(!vused[a]){\n          vused[a]=true;\n          map.put(x,map.getOrDefault(x,0l)+H);\n          W--;\n        }\n      }\n    }\n    map.putAll(java.util.Collections.singletonMap(0L, (long)W * H)); // Fixed statement"
        },
        "prompt_apr_4": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 36,\n        \"fixed_statement\": \"System.out.println(colors.size());\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 36,\n        \"fixed_statement\": \"System.out.println(color + \\\" \\\" + map.get(color));\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 36,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long) W * H);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 36,\n        \"fixed_statement\": \"map.put(0,map.getOrDefault(0,0L)+(long)W*H);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 36,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long) W * H);\"\n    }\n]"
        },
        "prompt_apr_5": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 21,\n        \"fixed_statement\": \"map.put(0L,map.getOrDefault(0L,0L)+((long)W)*H);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 25,\n        \"fixed_statement\": \"map.put(0,map.getOrDefault(0,0L)+(long)W*H);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0L, 0L) + (long)W * H);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 33,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long)W * H);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 27,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long) W * H);\"\n    }\n]"
        },
        "prompt_apr_6": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 21,\n        \"fixed_statement\": \"map.put(0L,map.getOrDefault(0L,0L)+((long)W)*H);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 34,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long)W * H);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 33,\n        \"fixed_statement\": \"map.put(0L, map.getOrDefault(0L, 0L) + (long)W * H);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 34,\n        \"fixed_statement\": \"map.put(0,map.getOrDefault(0,0L)+(long)W*H);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 34,\n        \"fixed_statement\": \"map.put(0, map.getOrDefault(0, 0L) + (long)W * (long)H);\"\n    }\n]"
        }
    }
]