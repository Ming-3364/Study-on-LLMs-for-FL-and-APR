[
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/DatabindContext.java",
        "buggy_method": {
            "method_name": "resolveSubType",
            "method_body": "public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException\n    {\n        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n        //    check if any generics info is added; and only then ask factory\n        //    to do translation when necessary\n        if (subClass.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { // let caller handle this problem\n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        e.getMessage()));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }",
            "start_line": 170,
            "end_line": 202,
            "buggy_lines": [
                195
            ]
        },
        "buggy_method_src": "public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException\n    {\n        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n        //    check if any generics info is added; and only then ask factory\n        //    to do translation when necessary\n        if (subClass.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { // let caller handle this problem\n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        e.getMessage()));\n            }\n            if (baseType.isTypeOrSuperTypeOf(cls)) {\n                return getTypeFactory().constructSpecializedType(baseType, cls);\n            }\n        }\n        throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            26
        ],
        "buggy_statements": [
            "                        e.getMessage()));"
        ],
        "buggy_method_src_endswith_buggy_statement": "public JavaType resolveSubType(JavaType baseType, String subClass)\n        throws JsonMappingException\n    {\n        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n        //    check if any generics info is added; and only then ask factory\n        //    to do translation when necessary\n        if (subClass.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = getTypeFactory().constructFromCanonical(subClass);\n            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n                return t;\n            }\n        } else {\n            Class<?> cls;\n            try {\n                cls =  getTypeFactory().findClass(subClass);\n            } catch (ClassNotFoundException e) { // let caller handle this problem\n                return null;\n            } catch (Exception e) {\n                throw invalidTypeIdException(baseType, subClass, String.format(\n                        \"problem: (%s) %s\",\n                        e.getClass().getName(),\n                        e.getMessage()));"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
        "buggy_method": {
            "method_name": "parseDate",
            "method_body": "public Date parseDate(String dateStr) throws IllegalArgumentException\n    {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    e.getMessage()));\n        }\n    }",
            "start_line": 706,
            "end_line": 716,
            "buggy_lines": [
                714
            ]
        },
        "buggy_method_src": "public Date parseDate(String dateStr) throws IllegalArgumentException\n    {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    e.getMessage()));\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            9
        ],
        "buggy_statements": [
            "                    e.getMessage()));"
        ],
        "buggy_method_src_endswith_buggy_statement": "public Date parseDate(String dateStr) throws IllegalArgumentException\n    {\n        try {\n            DateFormat df = getDateFormat();\n            return df.parse(dateStr);\n        } catch (ParseException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Failed to parse Date value '%s': %s\", dateStr,\n                    e.getMessage()));"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java",
        "buggy_method": {
            "method_name": "instantiationException",
            "method_body": "public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        // Most likely problem with Creator definition, right?\n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = cause.getMessage()) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }",
            "start_line": 1597,
            "end_line": 1611,
            "buggy_lines": [
                1603
            ]
        },
        "buggy_method_src": "public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        // Most likely problem with Creator definition, right?\n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = cause.getMessage()) == null) {\n            excMsg = ClassUtil.nameOf(cause.getClass());\n        }\n        String msg = String.format(\"Cannot construct instance of %s, problem: %s\",\n                ClassUtil.nameOf(instClass), excMsg);\n        InvalidDefinitionException e = InvalidDefinitionException.from(_parser, msg, type);\n        e.initCause(cause);\n        return e;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            7
        ],
        "buggy_statements": [
            "        } else if ((excMsg = cause.getMessage()) == null) {"
        ],
        "buggy_method_src_endswith_buggy_statement": "public JsonMappingException instantiationException(Class<?> instClass, Throwable cause) {\n        // Most likely problem with Creator definition, right?\n        final JavaType type = constructType(instClass);\n        String excMsg;\n        if (cause == null) {\n            excMsg = \"N/A\";\n        } else if ((excMsg = cause.getMessage()) == null) {"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
        "buggy_method": {
            "method_name": "fromUnexpectedIOE",
            "method_body": "public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        src.getMessage()));\n    }",
            "start_line": 335,
            "end_line": 340,
            "buggy_lines": [
                339
            ]
        },
        "buggy_method_src": "public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        src.getMessage()));\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            5
        ],
        "buggy_statements": [
            "                        src.getMessage()));"
        ],
        "buggy_method_src_endswith_buggy_statement": "public static JsonMappingException fromUnexpectedIOE(IOException src) {\n        return new JsonMappingException(null,\n                String.format(\"Unexpected IOException (of type %s): %s\",\n                        src.getClass().getName(),\n                        src.getMessage()));"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java",
        "buggy_method": {
            "method_name": "wrapWithPath",
            "method_body": "@SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n    {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            // [databind#2128]: try to avoid duplication\n            String msg = src.getMessage();\n            // Let's use a more meaningful placeholder if all we have is null\n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along\n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }",
            "start_line": 372,
            "end_line": 397,
            "buggy_lines": [
                380
            ]
        },
        "buggy_method_src": "@SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n    {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            // [databind#2128]: try to avoid duplication\n            String msg = src.getMessage();\n            // Let's use a more meaningful placeholder if all we have is null\n            if (msg == null || msg.length() == 0) {\n                msg = \"(was \"+src.getClass().getName()+\")\";\n            }\n            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along\n            Closeable proc = null;\n            if (src instanceof JsonProcessingException) {\n                Object proc0 = ((JsonProcessingException) src).getProcessor();\n                if (proc0 instanceof Closeable) {\n                    proc = (Closeable) proc0;\n                }\n            }\n            jme = new JsonMappingException(proc, msg, src);\n        }\n        jme.prependPath(ref);\n        return jme;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            9
        ],
        "buggy_statements": [
            "            String msg = src.getMessage();"
        ],
        "buggy_method_src_endswith_buggy_statement": "@SuppressWarnings(\"resource\")\n    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n    {\n        JsonMappingException jme;\n        if (src instanceof JsonMappingException) {\n            jme = (JsonMappingException) src;\n        } else {\n            // [databind#2128]: try to avoid duplication\n            String msg = src.getMessage();"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java",
        "buggy_method": {
            "method_name": "_createAndCacheUntypedSerializer",
            "method_body": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException\n    {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null; // doesn't matter but compiler whines otherwise\n            reportMappingProblem(iae, iae.getMessage());\n        }\n\n        if (ser != null) {\n            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key\n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }",
            "start_line": 1330,
            "end_line": 1349,
            "buggy_lines": [
                1341
            ]
        },
        "buggy_method_src": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException\n    {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null; // doesn't matter but compiler whines otherwise\n            reportMappingProblem(iae, iae.getMessage());\n        }\n\n        if (ser != null) {\n            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key\n            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);\n        }\n        return ser;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            12
        ],
        "buggy_statements": [
            "            reportMappingProblem(iae, iae.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)\n        throws JsonMappingException\n    {\n        JavaType fullType = _config.constructType(rawType);\n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(fullType);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null; // doesn't matter but compiler whines otherwise\n            reportMappingProblem(iae, iae.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java",
        "buggy_method": {
            "method_name": "_createAndCacheUntypedSerializer",
            "method_body": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException\n    {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null;\n            reportMappingProblem(iae, iae.getMessage());\n        }\n    \n        if (ser != null) {\n            // 21-Dec-2015, tatu: Should we also cache using raw key?\n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }",
            "start_line": 1351,
            "end_line": 1369,
            "buggy_lines": [
                1361
            ]
        },
        "buggy_method_src": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException\n    {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null;\n            reportMappingProblem(iae, iae.getMessage());\n        }\n    \n        if (ser != null) {\n            // 21-Dec-2015, tatu: Should we also cache using raw key?\n            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n        }\n        return ser;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            11
        ],
        "buggy_statements": [
            "            reportMappingProblem(iae, iae.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)\n        throws JsonMappingException\n    {        \n        JsonSerializer<Object> ser;\n        try {\n            ser = _createUntypedSerializer(type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            ser = null;\n            reportMappingProblem(iae, iae.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
        "buggy_method": {
            "method_name": "findTypeDeserializer",
            "method_body": "@Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }",
            "start_line": 1554,
            "end_line": 1593,
            "buggy_lines": [
                1589
            ]
        },
        "buggy_method_src": "@Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);\n            e.initCause(e0);\n            throw e;\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            36
        ],
        "buggy_statements": [
            "                    e0.getMessage(), baseType);"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Override\n    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n            JavaType baseType)\n        throws JsonMappingException\n    {\n        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n        AnnotatedClass ac = bean.getClassInfo();\n        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n        // Ok: if there is no explicit type info handler, we may want to\n        // use a default. If so, config object knows what to use.\n        Collection<NamedType> subtypes = null;\n        if (b == null) {\n            b = config.getDefaultTyper(baseType);\n            if (b == null) {\n                return null;\n            }\n        } else {\n            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n        }\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n        //    map to better type here\n        try {\n            return b.buildTypeDeserializer(config, baseType, subtypes);\n        } catch (IllegalArgumentException e0) {\n            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,\n                    e0.getMessage(), baseType);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
        "buggy_method": {
            "method_name": "buildBeanDeserializer",
            "method_body": "@SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
            "start_line": 201,
            "end_line": 256,
            "buggy_lines": [
                222
            ]
        },
        "buggy_method_src": "@SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            22
        ],
        "buggy_statements": [
            "                    e.getMessage(),"
        ],
        "buggy_method_src_endswith_buggy_statement": "@SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java",
        "buggy_method": {
            "method_name": "buildBuilderBasedDeserializer",
            "method_body": "@SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n        // Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
            "start_line": 265,
            "end_line": 323,
            "buggy_lines": [
                281
            ]
        },
        "buggy_method_src": "@SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n        // Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),\n                    builderDesc, null);\n        }\n        final DeserializationConfig config = ctxt.getConfig();\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then \"with methods\" for deserializing from JSON Object\n        addBeanProps(ctxt, builderDesc, builder);\n        addObjectIdReader(ctxt, builderDesc, builder);\n        \n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, builderDesc, builder);\n        addInjectables(ctxt, builderDesc, builder);\n\n        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n        final String buildMethodName = (builderConfig == null) ?\n                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n        \n        // and lastly, find build method to use:\n        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n        if (buildMethod != null) { // note: can't yet throw error; may be given build method\n            if (config.canOverrideAccessModifiers()) {\n            \tClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n        // this may give us more information...\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, builderDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer = builder.buildBuilderBased(\n        \t\tvalueType, buildMethodName);\n\n        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            17
        ],
        "buggy_statements": [
            "                    e.getMessage(),"
        ],
        "buggy_method_src_endswith_buggy_statement": "@SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(\n    \t\tDeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)\n        throws JsonMappingException\n    {\n        // Creators, anyone? (to create builder itself)\n        ValueInstantiator valueInstantiator;\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(),\n                    e.getMessage(),"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
        "buggy_method": {
            "method_name": "_createAndCache2",
            "method_body": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }",
            "start_line": 258,
            "end_line": 300,
            "buggy_lines": [
                268
            ]
        },
        "buggy_method_src": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            11
        ],
        "buggy_statements": [
            "            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java",
        "buggy_method": {
            "method_name": "_throwAsIOE",
            "method_body": "protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, t.getMessage(), t);\n    }",
            "start_line": 194,
            "end_line": 215,
            "buggy_lines": [
                202,
                214
            ]
        },
        "buggy_method_src": "protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, t.getMessage(), t);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            9,
            21
        ],
        "buggy_statements": [
            "            String origMsg = e.getMessage();",
            "        throw new JsonMappingException(null, t.getMessage(), t);"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected void _throwAsIOE(Exception e, Object propName, Object value)\n        throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n            msg.append(\"; actual type: \").append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \").append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw new JsonMappingException(null, msg.toString(), e);\n        }\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable t = ClassUtil.getRootCause(e);\n        throw new JsonMappingException(null, t.getMessage(), t);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java",
        "buggy_method": {
            "method_name": "_throwAsIOE",
            "method_body": "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }",
            "start_line": 580,
            "end_line": 600,
            "buggy_lines": [
                590
            ]
        },
        "buggy_method_src": "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = e.getMessage();\n            if (origMsg != null) {\n                msg.append(\", problem: \")\n                    .append(origMsg);\n            } else {\n                msg.append(\" (no error message provided)\");\n            }\n            throw JsonMappingException.from(p, msg.toString(), e);\n        }\n        _throwAsIOE(p, e);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            11
        ],
        "buggy_statements": [
            "            String origMsg = e.getMessage();"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException\n    {\n        if (e instanceof IllegalArgumentException) {\n            String actType = ClassUtil.classNameOf(value);\n            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\")\n                    .append(getName())\n                    .append(\"' (expected type: \")\n                    .append(getType())\n                    .append(\"; actual type: \")\n                    .append(actType).append(\")\");\n            String origMsg = e.getMessage();"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java",
        "buggy_method": {
            "method_name": "_throwAsIOE",
            "method_body": "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException\n    {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, th.getMessage(), th);\n    }",
            "start_line": 605,
            "end_line": 612,
            "buggy_lines": [
                611
            ]
        },
        "buggy_method_src": "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException\n    {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, th.getMessage(), th);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            7
        ],
        "buggy_statements": [
            "        throw JsonMappingException.from(p, th.getMessage(), th);"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException\n    {\n        ClassUtil.throwIfIOE(e);\n        ClassUtil.throwIfRTE(e);\n        // let's wrap the innermost problem\n        Throwable th = ClassUtil.getRootCause(e);\n        throw JsonMappingException.from(p, th.getMessage(), th);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java",
        "buggy_method": {
            "method_name": "_parseDate",
            "method_body": "protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException\n    {\n        try {\n            // Take empty Strings to mean 'empty' Value, usually 'null':\n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    iae.getMessage());\n        }\n    }",
            "start_line": 514,
            "end_line": 528,
            "buggy_lines": [
                526
            ]
        },
        "buggy_method_src": "protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException\n    {\n        try {\n            // Take empty Strings to mean 'empty' Value, usually 'null':\n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    iae.getMessage());\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            13
        ],
        "buggy_statements": [
            "                    iae.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected java.util.Date _parseDate(String value, DeserializationContext ctxt)\n        throws IOException\n    {\n        try {\n            // Take empty Strings to mean 'empty' Value, usually 'null':\n            if (_isEmptyOrTextualNull(value)) {\n                return (java.util.Date) getNullValue(ctxt);\n            }\n            return ctxt.parseDate(value);\n        } catch (IllegalArgumentException iae) {\n            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,\n                    \"not a valid representation (error: %s)\",\n                    iae.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "buggy_method": {
            "method_name": "deserializeKey",
            "method_body": "@Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
            "start_line": 120,
            "end_line": 141,
            "buggy_lines": [
                135
            ]
        },
        "buggy_method_src": "@Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    re.getMessage());\n        }\n        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n            return null;\n        }\n        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            16
        ],
        "buggy_statements": [
            "                    re.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Override\n    public Object deserializeKey(String key, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (key == null) { // is this even legal call?\n            return null;\n        }\n        try {\n            Object result = _parse(key, ctxt);\n            if (result != null) {\n                return result;\n            }\n        } catch (Exception re) {\n            return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\",\n                    re.getClass().getName(),\n                    re.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java",
        "buggy_method": {
            "method_name": "_weirdKey",
            "method_body": "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                e.getMessage());\n    }",
            "start_line": 260,
            "end_line": 263,
            "buggy_lines": [
                262
            ]
        },
        "buggy_method_src": "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                e.getMessage());\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            3
        ],
        "buggy_statements": [
            "                e.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected Object _weirdKey(DeserializationContext ctxt, String key, Exception e) throws IOException {\n        return ctxt.handleWeirdKey(_keyClass, key, \"problem: %s\",\n                e.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java",
        "buggy_method": {
            "method_name": "wrapException",
            "method_body": "@Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t)\n    {\n        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n        //   does so if and until `JsonMappingException` is found.\n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n    }",
            "start_line": 445,
            "end_line": 457,
            "buggy_lines": [
                456
            ]
        },
        "buggy_method_src": "@Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t)\n    {\n        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n        //   does so if and until `JsonMappingException` is found.\n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            12
        ],
        "buggy_statements": [
            "                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Deprecated // since 2.7\n    protected JsonMappingException wrapException(Throwable t)\n    {\n        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only\n        //   does so if and until `JsonMappingException` is found.\n        for (Throwable curr = t; curr != null; curr = curr.getCause()) {\n            if (curr instanceof JsonMappingException) {\n                return (JsonMappingException) curr;\n            }\n        }\n        return new JsonMappingException(null,\n                \"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java",
        "buggy_method": {
            "method_name": "instantiateBean",
            "method_body": "@Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +t.getMessage(), t);\n        }\n    }",
            "start_line": 344,
            "end_line": 366,
            "buggy_lines": [
                364
            ]
        },
        "buggy_method_src": "@Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +t.getMessage(), t);\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            21
        ],
        "buggy_statements": [
            "                    +t.getMessage(), t);"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Override\n    public Object instantiateBean(boolean fixAccess) {\n        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n        if (ac == null) {\n            return null;\n        }\n        if (fixAccess) {\n            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        try {\n            return ac.getAnnotated().newInstance();\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t.getCause() != null) {\n                t = t.getCause();\n            }\n            ClassUtil.throwIfError(t);\n            ClassUtil.throwIfRTE(t);\n            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"\n                    +_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"\n                    +t.getMessage(), t);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java",
        "buggy_method": {
            "method_name": "includeFilterSuppressNulls",
            "method_body": "@Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException\n    {\n        if (filter == null) {\n            return true;\n        }\n        // should let filter decide what to do with nulls:\n        // But just case, let's handle unexpected (from our perspective) problems explicitly\n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; // never gets here\n        }\n    }",
            "start_line": 158,
            "end_line": 175,
            "buggy_lines": [
                171
            ]
        },
        "buggy_method_src": "@Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException\n    {\n        if (filter == null) {\n            return true;\n        }\n        // should let filter decide what to do with nulls:\n        // But just case, let's handle unexpected (from our perspective) problems explicitly\n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());\n            reportBadDefinition(filter.getClass(), msg, t);\n            return false; // never gets here\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            14
        ],
        "buggy_statements": [
            "filter.getClass().getName(), t.getClass().getName(), t.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Override\n    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException\n    {\n        if (filter == null) {\n            return true;\n        }\n        // should let filter decide what to do with nulls:\n        // But just case, let's handle unexpected (from our perspective) problems explicitly\n        try {\n            return filter.equals(null);\n        } catch (Throwable t) {\n            String msg = String.format(\n\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\",\nfilter.getClass().getName(), t.getClass().getName(), t.getMessage());"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java",
        "buggy_method": {
            "method_name": "_wrapAsIOE",
            "method_body": "private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }",
            "start_line": 501,
            "end_line": 510,
            "buggy_lines": [
                505
            ]
        },
        "buggy_method_src": "private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            5
        ],
        "buggy_statements": [
            "        String msg = e.getMessage();"
        ],
        "buggy_method_src_endswith_buggy_statement": "private IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java",
        "buggy_method": {
            "method_name": "buildWriter",
            "method_body": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, e.getMessage());\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n            //    type information for contents. Should work well (for JAXB case); can be\n            //    revisited if this causes problems.\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Mar-2017: [databind#1522] Allow config override per property type\n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            // neither Setter nor ConstructorParameter are expected here\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we cannot for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: // new with 2.9\n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { // is this legal?\n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }",
            "start_line": 91,
            "end_line": 244,
            "buggy_lines": [
                103,
                105
            ]
        },
        "buggy_method_src": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, e.getMessage());\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (contentTypeSer != null) {\n            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n            //    type information for contents. Should work well (for JAXB case); can be\n            //    revisited if this causes problems.\n            if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                serializationType = declaredType;\n            }\n            JavaType ct = serializationType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (ct == null) {\n                prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                        \"serialization type \"+serializationType+\" has no content\");\n            }\n            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n            ct = serializationType.getContentType();\n        }\n\n        Object valueToSuppress = null;\n        boolean suppressNulls = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n        \n        // 17-Mar-2017: [databind#1522] Allow config override per property type\n        AnnotatedMember accessor = propDef.getAccessor();\n        if (accessor == null) {\n            // neither Setter nor ConstructorParameter are expected here\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"could not determine property type\");\n        }\n        Class<?> rawPropertyType = accessor.getRawType();\n\n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),\n                rawPropertyType, _defaultInclusion);\n\n        // property annotation override\n        \n        inclV = inclV.withOverrides(propDef.findInclusion());\n\n        JsonInclude.Include inclusion = inclV.getValueInclusion();\n        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n            inclusion = JsonInclude.Include.ALWAYS;\n        }\n        switch (inclusion) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n            Object defaultBean;\n\n            // 16-Oct-2016, tatu: Note: if we cannot for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                try {\n                    valueToSuppress = am.getValue(defaultBean);\n                } catch (Exception e) {\n                    _throwWrapped(e, propDef.getName(), defaultBean);\n                }\n            } else {\n                valueToSuppress = BeanUtil.getDefaultValue(actualType);\n                suppressNulls = true;\n            }\n            if (valueToSuppress == null) {\n                suppressNulls = true;\n            } else {\n                if (valueToSuppress.getClass().isArray()) {\n                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            suppressNulls = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (actualType.isReferenceType()) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            suppressNulls = true;\n            // but possibly also 'empty' values:\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case CUSTOM: // new with 2.9\n            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());\n            if (valueToSuppress == null) { // is this legal?\n                suppressNulls = true;\n            } else {\n                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);\n            }\n            break;\n        case NON_NULL:\n            suppressNulls = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections\n            if (actualType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        Class<?>[] views = propDef.findViews();\n        if (views == null) {\n            views = _beanDesc.findDefaultViews();\n        }\n        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n                am, _beanDesc.getClassAnnotations(), declaredType,\n                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);\n\n        // How about custom null serializer?\n        Object serDef = _annotationIntrospector.findNullSerializer(am);\n        if (serDef != null) {\n            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n        if (unwrapper != null) {\n            bpw = bpw.unwrappingWriter(unwrapper);\n        }\n        return bpw;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition\njunit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n at [Source: (String)\"{\"value\":\"foo\"}\"; line: 1, column: 2]\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n",
        "buggy_lines_in_method": [
            13,
            15
        ],
        "buggy_statements": [
            "                return prov.reportBadDefinition(declaredType, e.getMessage());",
            "            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n            AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n    {\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType serializationType;\n        try {\n            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n        } catch (JsonMappingException e) {\n            if (propDef == null) {\n                return prov.reportBadDefinition(declaredType, e.getMessage());\n            }\n            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());"
    }
]