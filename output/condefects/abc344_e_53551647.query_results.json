[
    {
        "prompt_fl_1": {
            "qwen-turbo": "7",
            "doubao-pro-4k": "18",
            "ernie-3.5-128k": "**32**",
            "deepseek-chat": "14",
            "gpt-4o-mini": "26"
        },
        "prompt_fl_4": {
            "qwen-turbo": "back.put(y, x_back);",
            "doubao-pro-4k": "back.put(y, x_back);",
            "ernie-3.5-128k": "back.put(x_back, y);",
            "deepseek-chat": "```java\nint top = 0;\n```",
            "gpt-4o-mini": "front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);"
        },
        "prompt_apr_1": {
            "qwen-turbo": "Certainly! The issue on line [28] seems to be related to how the `front` and `back` maps are being updated when performing operations. Specifically, when an element is moved, the adjacent elements' references need to be correctly adjusted.\n\nHere's the complete corrected method with the bug fixed:\n\n```java\npublic static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    \n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    \n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            int x_front = front.get(x);\n\n            // Update 'back' for the element before x\n            if (x_front != -1) {\n                back.put(x_front, y);\n            }\n\n            // Update 'front' for the element after x\n            if (x_back != -1) {\n                front.put(x_back, y);\n            }\n\n            // Update 'front' for y\n            front.put(y, x_front);\n\n            // Update 'back' for y\n            back.put(y, x_back);\n\n            // Remove old references for x\n            front.remove(x);\n            back.remove(x);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n\n            if (x_front != -1) {\n                back.put(x_front, x_back);\n            }\n\n            if (x_back != -1) {\n                front.put(x_back, x_front);\n            }\n\n            // Remove old references for x\n            front.remove(x);\n            back.remove(x);\n        }\n    }\n\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) {\n            top = key;\n        }\n    }\n\n    int now = top;\n    while (now != -1) {\n        out.print(now + \" \");\n        now = back.get(now);\n    }\n    out.println();\n    out.flush();\n}\n```\n\nIn this corrected version:\n- I added checks for `x_front` and `x_back` to ensure they are not `-1` before updating the corresponding entries in the `front` and `back` maps.\n- After updating the references, I removed the old references for the element `x` from both `front` and `back`.\n- The final loop prints the sequence in a more readable format by adding spaces between numbers and moving the newline to the end.",
            "gpt-4o-mini": "public static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc = new InputReader(System.in);\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint q = sc.nextInt();\n\t\tHashMap<Integer, Integer> front = new HashMap<>();\n\t\tHashMap<Integer, Integer> back = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfront.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n\t\t\tback.put(a[i], i + 1 < n ? a[i + 1] : -1);\n\t\t}\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (sc.nextInt() == 1) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tback.put(x, y);\n\t\t\t\tif (x_back != -1) front.put(x_back, y);\n\t\t\t\tfront.put(y, x);\n\t\t\t\tback.put(y, x_back);\n\t\t\t}else {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint x_front = front.get(x);\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tif (x_front != -1) back.put(x_front, x_back);\n\t\t\t\tif (x_back != -1) front.put(x_back, x_front);\n\t\t\t}\n\t\t}\n\t\tint top = -1; // Fix: Initialize `top` to -1\n\t\tfor (int key : front.keySet()) {\n\t\t\tif (front.get(key) == -1) {\n\t\t\t\ttop = key;\n\t\t\t\tbreak; // Fix: Break once the top is found\n\t\t\t}\n\t\t}\n\t\tint now = top;\n\t\twhile (now != -1) {\n\t\t\tout.println(now);\n\t\t\tnow = back.get(now);\n\t\t}\n\t\tout.flush();\n\t}",
            "deepseek-chat": "The bug in line 28 is that when you remove an element `x` from the list, you need to update the `front` and `back` references of its neighboring elements, but you also need to ensure that the `front` and `back` maps are updated correctly. Specifically, when `x` is removed, the `back` of `x_front` should point to `x_back`, and the `front` of `x_back` should point to `x_front`. However, the code does not handle the case where `x_back` is `-1` correctly.\n\nHere is the corrected method:\n\n```java\npublic static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back != -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front != -1) back.put(x_front, x_back);\n            if (x_back != -1) front.put(x_back, x_front);\n            front.remove(x);  // Remove x from the front map\n            back.remove(x);   // Remove x from the back map\n        }\n    }\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) top = key;\n    }\n    int now = top;\n    while (now != -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}\n```\n\nThe key changes are:\n1. Added `front.remove(x);` and `back.remove(x);` to remove `x` from the `front` and `back` maps after updating the neighboring elements.\n2. This ensures that `x` is no longer part of the list and prevents any potential issues when traversing the list later.\n\nThis should fix the bug and ensure that the list is correctly updated when elements are removed.",
            "doubao-pro-4k": "public static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc=new InputReader(System.in);    \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back!= -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        }else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front!= -1) back.put(x_front, x_back);\n            if (x_back!= -1) front.put(x_back, x_front);\n        }\n    }\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) top = key;\n    }\n    int now = top;\n    while (now!= -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}",
            "ernie-3.5-128k": "public static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint q = sc.nextInt();\n\t\tHashMap<Integer, Integer> front = new HashMap<>();\n\t\tHashMap<Integer, Integer> back = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfront.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n\t\t\tback.put(a[i], i + 1 < n ? a[i + 1] : -1);\n\t\t}\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (sc.nextInt() == 1) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint x_index = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] == x) {\n\t\t\t\t\t\tx_index = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tint y_index = -1;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (a[j] == y) {\n\t\t\t\t\t\ty_index = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update the array to reflect the swap\n\t\t\t\tint temp = a[x_index];\n\t\t\t\ta[x_index] = a[y_index];\n\t\t\t\ta[y_index] = temp;\n\n\t\t\t\t// Update the front and back mappings\n\t\t\t\tback.put(x, y);\n\t\t\t\tif (x_back != -1) front.put(x_back, y);\n\t\t\t\tfront.put(y, x);\n\t\t\t\tback.put(y, x_back);\n\n\t\t\t\t// Update the indices in the array for any further operations\n\t\t\t\t// (though not strictly necessary for this specific problem, good practice)\n\t\t\t}else {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint x_front = front.get(x);\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tif (x_front != -1) {\n\t\t\t\t\tint x_front_index = -1;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (a[j] == x_front) {\n\t\t\t\t\t\t\tx_front_index = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x_front_index + 1 < n) back.put(x_front, a[x_front_index + 1]);\n\t\t\t\t\telse back.put(x_front, -1);\n\t\t\t\t\tif (x_front_index - 1 >= 0) front.put(a[x_front_index - 1], x_front);\n\t\t\t\t\telse front.put(-1, x_front);\n\t\t\t\t}\n\t\t\t\tif (x_back != -1) {\n\t\t\t\t\tint x_back_index = -1;\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (a[j] == x_back) {\n\t\t\t\t\t\t\tx_back_index = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x_back_index + 1 < n) back.put(x_back, a[x_back_index + 1]);\n\t\t\t\t\telse back.put(x_back, -1);\n\t\t\t\t\tif (x_back_index - 1 >= 0) front.put(a[x_back_index - 1], x_back);\n\t\t\t\t\telse front.put(-1, x_back);\n\t\t\t\t}\n\t\t\t\t// Remove x from the list by setting its front and back to -1\n\t\t\t\tfront.remove(x);\n\t\t\t\tback.remove(x);\n\t\t\t\t// Update the array to reflect the removal by setting it to a placeholder or shifting elements (not done here)\n\t\t\t}\n\t\t}\n\t\tint top = 0;\n\t\tfor (int key : front.keySet()) {\n\t\t\tif (front.get(key) == -1) top = key;\n\t\t}\n\t\tint now = top;\n\t\twhile (now != -1) {\n\t\t\tout.println(now);\n\t\t\tnow = back.get(now);\n\t\t}\n\t\tout.flush();\n\t}"
        },
        "prompt_apr_2": {
            "gpt-4o-mini": "public static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back != -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front != -1) back.put(x_front, x_back);\n            if (x_back != -1) front.put(x_back, x_front);\n        }\n    }\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) top = key;\n    }\n    int now = top;\n    while (now != -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}",
            "deepseek-chat": "The bug in the code is likely due to the missing closing brace for the `main` method. Here is the complete corrected method with the missing closing brace added:\n\npublic static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc=new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back != -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front != -1) back.put(x_front, x_back);\n            if (x_back != -1) front.put(x_back, x_front);\n        }\n    }\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) top = key;\n    }\n    int now = top;\n    while (now != -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}",
            "qwen-turbo": "Certainly! The provided code has a few issues that need to be addressed:\n\n1. The `InputReader` class is assumed to be defined elsewhere, but it's important to ensure it correctly reads integers and integer arrays.\n2. The logic for updating the `front` and `back` maps needs to handle edge cases properly.\n3. The output should start from the top element and traverse the list using the `back` map.\n\nHere is the corrected version of your code:\n\n```java\nimport java.util.HashMap;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    \n    // Initialize front and back maps\n    for (int i = 0; i < n; i++) {\n        if (i > 0) {\n            front.put(a[i], a[i - 1]);\n        }\n        if (i < n - 1) {\n            back.put(a[i], a[i + 1]);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.getOrDefault(x, -1);\n            int x_front = front.getOrDefault(x, -1);\n\n            // Update back pointers\n            if (x_back != -1) {\n                back.put(x_back, y);\n            } else {\n                front.remove(x);\n            }\n\n            // Update front pointers\n            if (x_front != -1) {\n                front.put(x_front, y);\n            } else {\n                back.remove(x);\n            }\n\n            // Update new connections\n            back.put(y, x_back);\n            front.put(y, x_front);\n            front.put(x, y);\n            back.put(x, y);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.getOrDefault(x, -1);\n            int x_back = back.getOrDefault(x, -1);\n\n            // Update front pointers\n            if (x_front != -1) {\n                back.put(x_front, x_back);\n            } else {\n                front.remove(x);\n            }\n\n            // Update back pointers\n            if (x_back != -1) {\n                front.put(x_back, x_front);\n            } else {\n                back.remove(x);\n            }\n\n            // Remove old connections\n            front.remove(x);\n            back.remove(x);\n        }\n    }\n\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) {\n            top = key;\n        }\n    }\n    int now = top;\n    while (now != -1) {\n        out.print(now + \" \");\n        now = back.get(now);\n    }\n    out.println();\n    out.flush();\n}\n```\n\n### Explanation:\n1. **Initialization of `front` and `back` Maps:**\n   - The initial loop correctly initializes the `front` and `back` maps based on the input array `a`.\n\n2. **Handling Edge Cases:**\n   - Use `getOrDefault` to handle cases where the key does not exist in the map.\n   - Properly remove entries from `front` and `back` when an element is removed.\n\n3. **Output Logic:**\n   - Start from the top element and traverse the list using the `back` map to print the elements in order.\n\nMake sure the `InputReader` class is correctly implemented to read integers and integer arrays. If you have any specific implementation of `InputReader`, please provide it so I can further refine the solution.",
            "doubao-pro-4k": "public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);\n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back!= -1) {\n                front.put(x_back, y);\n            }\n            front.put(y, x);\n            back.put(y, x_back);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front!= -1) {\n                back.put(x_front, x_back);\n            }\n            if (x_back!= -1) {\n                front.put(x_back, x_front);\n            }\n        }\n    }\n    int top = 0;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) {\n            top = key;\n        }\n    }\n    int now = top;\n    while (now!= -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}",
            "ernie-3.5-128k": "Sure, let's analyze and correct the given code. The main issue seems to be with handling the updates and deletions correctly in the HashMaps `front` and `back`. Specifically, when an element `x` is removed (operation 2), you need to ensure that the adjacent elements are properly updated to reflect the removal.\n\nHere's the corrected version of your `main` method:\n\npublic static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);\n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n\n    // Populate initial front and back mappings\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n\n    // Process queries\n    for (int i = 0; i < q; i++) {\n        int operation = sc.nextInt();\n        if (operation == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n\n            // Update adjacent elements' references\n            int x_back = back.get(x);\n            int y_front = front.getOrDefault(y, -1);\n\n            if (x_back != -1) {\n                front.put(x_back, y);\n            }\n            if (y_front != -1) {\n                back.put(y_front, x);\n            }\n\n            // Update x and y's references\n            front.put(y, x);\n            back.put(x, y);\n\n            // Remove old references from the map (if any)\n            front.remove(x);\n            back.remove(y);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n\n            // Remove x from the list\n            if (x_front != -1) {\n                back.put(x_front, x_back);\n            }\n            if (x_back != -1) {\n                front.put(x_back, x_front);\n            }\n\n            // Remove x from both maps\n            front.remove(x);\n            back.remove(x);\n        }\n    }\n\n    // Find the new top element and print the list\n    int top = -1;\n    for (int key : front.keySet()) {\n        if (front.get(key) == -1) {\n            top = key;\n            break;\n        }\n    }\n\n    int now = top;\n    while (now != -1) {\n        out.println(now);\n        now = back.get(now);\n    }\n    out.flush();\n}\n\nKey corrections and improvements:\n1. When performing operation 1 (swapping `x` and `y`), ensure to remove old references from `front` and `back` after updating the new references.\n2. When performing operation 2 (removing `x`), properly update the adjacent elements to reflect the removal of `x`.\n3. Ensure to handle edge cases where an element might not have a front or back reference (e.g., first or last element in the list).\n\nThese changes should make the code work correctly for both operations."
        },
        "prompt_apr_3": {
            "qwen-turbo": "```java\npublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint q = sc.nextInt();\n\t\tHashMap<Integer, Integer> front = new HashMap<>();\n\t\tHashMap<Integer, Integer> back = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfront.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n\t\t\tback.put(a[i], i + 1 < n ? a[i + 1] : -1);\n\t\t}\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (sc.nextInt() == 1) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tback.put(x, y);\n\t\t\t\tif (x_back != -1) front.put(x_back, y);\n\t\t\t\tfront.put(y, x);\n\t\t\t\tback.put(y, x_back);\n\t\t\t}else {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint x_front = front.get(x);\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tif (x_front != -1) back.put(x_front, x_back);\n\t\t\t\tif (x_back != -1) front.put(x_back, x_front);\n\t\t\t}\n```",
            "gpt-4o-mini": "public static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc = new InputReader(System.in);        \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back != -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        } else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front != -1) back.put(x_front, x_back);\n            if (x_back != -1) front.put(x_back, x_front);\n        }\n    }  \n}",
            "deepseek-chat": "```java\npublic static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc=new InputReader(System.in);\t\t\n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n ? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back != -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        }else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front != -1) back.put(x_front, x_back);\n            if (x_back != -1) front.put(x_back, x_front);\n        }\n    }\n}\n```",
            "doubao-pro-4k": "public static void main(String[] args){\n    PrintWriter out = new PrintWriter(System.out);\n    InputReader sc=new InputReader(System.in);    \n    int n = sc.nextInt();\n    int[] a = sc.nextIntArray(n);\n    int q = sc.nextInt();\n    HashMap<Integer, Integer> front = new HashMap<>();\n    HashMap<Integer, Integer> back = new HashMap<>();\n    for (int i = 0; i < n; i++) {\n        front.put(a[i], i - 1 >= 0? a[i - 1] : -1);\n        back.put(a[i], i + 1 < n? a[i + 1] : -1);\n    }\n    for (int i = 0; i < q; i++) {\n        if (sc.nextInt() == 1) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int x_back = back.get(x);\n            back.put(x, y);\n            if (x_back!= -1) front.put(x_back, y);\n            front.put(y, x);\n            back.put(y, x_back);\n        }else {\n            int x = sc.nextInt();\n            int x_front = front.get(x);\n            int x_back = back.get(x);\n            if (x_front!= -1) back.put(x_front, x_back);\n            if (x_back!= -1) front.put(x_back, x_front);\n        }\n\n        if (x_front!= -1) back.put(x_front, x_back);\n        if (x_back!= -1) front.put(x_back, x_front);\n    }\n}",
            "ernie-3.5-128k": "public static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\t\t\n\t\tint n = sc.nextInt();\n\t\tint[] a = sc.nextIntArray(n);\n\t\tint q = sc.nextInt();\n\t\tHashMap<Integer, Integer> front = new HashMap<>();\n\t\tHashMap<Integer, Integer> back = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfront.put(a[i], i - 1 >= 0 ? a[i - 1] : -1);\n\t\t\tback.put(a[i], i + 1 < n ? a[i + 1] : -1);\n\t\t}\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (sc.nextInt() == 1) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tback.put(x, y);\n\t\t\t\tif (x_back != -1) front.put(x_back, y);\n\t\t\t\tfront.put(y, x);\n\t\t\t\tback.put(y, x_back);\n\t\t\t}else {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint x_front = front.get(x);\n\t\t\t\tint x_back = back.get(x);\n\t\t\t\tif (x_front != -1) back.put(x_front, x_back == x ? -1 : x_back);\n\t\t\t\tif (x_back != -1) front.put(x_back, x_front == x ? -1 : x_front);\n\t\t\t}\n\t\t}"
        },
        "prompt_apr_4": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"if (x_back != -1) front.put(x_back, y);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"if (x_front != -1 && x_back != -1) { back.put(x_front, x_back); front.put(x_back, x_front); }\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"if (x_front!= -1 && x_back!= -1) back.put(x_front, x_back);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"front.put(y, x_back);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"if (x_back != -1) front.put(x_back, x_front);\"\n    }\n]"
        },
        "prompt_apr_5": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 2,\n        \"fixed_statement\": \"PrintWriter out = new PrintWriter(System.out, true);\"\n    },\n    {\n        \"line_number\": 14,\n        \"fixed_statement\": \"back.put(y, x_back);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 19,\n        \"fixed_statement\": \"for (int i = 0; i < n; i++) {\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 49,\n        \"fixed_statement\": \"out.println(now);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 28,\n        \"fixed_statement\": \"\\t\\t\\t\\tif (x_back != -1) back.put(x_front, x_back);\"\n    },\n    {\n        \"line_number\": 29,\n        \"fixed_statement\": \"\\t\\t\\t\\tif (x_back != -1) front.put(x_back, x_front);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 34,\n        \"fixed_statement\": \"\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tint x = sc.nextInt();\\n\\t\\t\\t\\tint x_front = front.remove(x);\\n\\t\\t\\t\\tint x_back = back.remove(x);\\n\\t\\t\\t\\tif (x_front != -1) back.put(x_front, x_back);\\n\\t\\t\\t\\tif (x_back != -1) front.put(x_back, x_front);\\n\\t\\t\\t}\"\n    }\n]"
        },
        "prompt_apr_6": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 21,\n        \"fixed_statement\": \"front.put(x, x_front);\"\n    },\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"back.put(x, x_back);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 27,\n        \"fixed_statement\": \"if (x_back != -1) front.put(x_back, x_front);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 29,\n        \"fixed_statement\": \"if (x_front!= -1) back.put(x_front, x_back);if (x_back!= -1) front.put(x_back, x_front);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 34,\n        \"fixed_statement\": \"front.remove(x); back.remove(x);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 39,\n        \"fixed_statement\": \"if (x_front != -1) back.put(x_front, x_back);\"\n    },\n    {\n        \"line_number\": 40,\n        \"fixed_statement\": \"if (x_back != -1) front.put(x_back, x_front);\"\n    }\n]"
        }
    }
]