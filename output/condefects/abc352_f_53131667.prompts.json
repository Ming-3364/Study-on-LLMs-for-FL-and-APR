[
    {
        "prompt_fl_1": "\nsource code:\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in the above code, please help me locate it.\n\nPlease output **only one integer**: the line number of the buggy code (The code starts from line 1). Do not provide any explanations or additional content.\n",
        "prompt_fl_4": "\nsource code:\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in the above code, please help me locate it.\n\nOutput **only** the exact buggy statement, with no line numbers, explanations, or additional content. Your response should contain just the buggy code line. Do not include ```java or ``` markers in the response.\n",
        "prompt_apr_1": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in line [53] of the code, please help me fix it.\n\nPlease return the **complete corrected method**. Do not skip or omit any part of the code. Do not include ```java or ``` markers in the response.\n",
        "prompt_apr_2": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in ['        gs.sort(Comparator.comparingInt(a -> a.cnt));'] , please help me fix it. \n\nPlease return the **complete corrected method**. Do not skip or omit any part of the code. Do not include ```java or ``` markers in the response.\n",
        "prompt_apr_3": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n\nThere is a bug in the last statement, please help me fix it.\n\nReturn the code **only from the method declaration to the fixed statement**, without completing or adding additional code. Do not modify anything beyond fixing the bug, and do not complete the `if` statement or other unfinished parts. Do not include ```java or ``` markers in the response.\n",
        "prompt_apr_4": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in line [53] of the code, please help me fix it.\n\nPlease return the results in a strict JSON format as described below. Please follow these instructions carefully:\n1. Your output must include each repaired line's number (`line_number`) and the corresponding fixed code statement (`fixed_statement`).\n2. The output format must be a valid JSON array, where each element represents one repaired line, with the following structure:\n   - `\"line_number\"`: The line number of the buggy code that was repaired (integer).\n   - `\"fixed_statement\"`: The repaired statement for that specific line (string).\n\n3. The result must strictly follow this format:\n[\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    },\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    }\n]\n4. The repaired statement in \"fixed_statement\" must replace the corresponding line in the buggy code.\n5. You must NOT include any additional explanation or description in your response. Only return the JSON array. Do not include ```json or ``` markers in the response.\n",
        "prompt_apr_5": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n        int sn  = 0;\n        res = new int[n];\n        Arrays.fill(res, -1);\n        for(int i=0; i<d; i++) {\n            G g = gs.get(i);\n            if(g.cnt == 1) {\n                sn++;\n            }\n        }\n        md = d;\n        if(sn >= 2) {\n            for(int i=0; i<d; i++) {\n                G g = gs.get(i);\n                if(g.cnt == 1) {\n                    res[g.root] = -1;\n                }\n            }\n            md -= sn;\n        }\n        dfs(md-1, 0, new int[md]);\n        for(int i=0; i<md; i++) {\n            G g = gs.get(i);\n            if(g.oset.size() != 1) {\n                continue;\n            }\n            int offset = g.oset.iterator().next();\n            res[g.root] = offset;\n            for(int j=0; j<n; j++) {\n                if(uf.root(j) == uf.root(g.root)) {\n                    res[j] = l[j] + offset;\n                }\n            }\n\n        }\n        \n        for(int i=0; i<res.length; i++) {\n            if(i>0) out.print(\" \");\n            if(res[i] >= 0) {\n                res[i]++;\n            }\n            out.print(res[i]);\n         }\n         out.println();\n    }\n\nThere is a bug in ['        gs.sort(Comparator.comparingInt(a -> a.cnt));'] , please help me fix it. \n\nPlease return the results in a strict JSON format as described below. Please follow these instructions carefully:\n1. Your output must include each repaired line's number (`line_number`) and the corresponding fixed code statement (`fixed_statement`).\n2. The output format must be a valid JSON array, where each element represents one repaired line, with the following structure:\n   - `\"line_number\"`: The line number of the buggy code that was repaired (integer).\n   - `\"fixed_statement\"`: The repaired statement for that specific line (string).\n\n3. The result must strictly follow this format:\n[\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    },\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    }\n]\n4. The repaired statement in \"fixed_statement\" must replace the corresponding line in the buggy code.\n5. You must NOT include any additional explanation or description in your response. Only return the JSON array. Do not include ```json or ``` markers in the response.\n",
        "prompt_apr_6": "\npublic void solve() {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        List<E>[] list = new List[n];\n        UFSize uf = new UFSize(n);\n        Arrays.setAll(list, i -> new ArrayList<>());\n        for(int i=0; i<m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int c = sc.nextInt();\n            list[a].add(new E(a, b, -c));\n            list[b].add(new E(b, a, c));\n            uf.join(a, b);\n        }\n        boolean[] v = new boolean[n];\n        int[] l = new int[n];\n        gs = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            if(uf.root(i) != i) continue;\n            Set<Integer> set = new HashSet<>();\n            set.add(i);\n            v[i] = true;\n            LinkedList<Integer> q = new LinkedList<>();\n            q.offer(i);\n            while(!q.isEmpty()) {\n                int u = q.poll();\n                for(E e : list[u]) {\n                    if(v[e.v]) continue;\n                    v[e.v] = true;\n                    l[e.v] = l[u] + e.c;\n                    q.offer(e.v);\n                    set.add(e.v);\n                }\n            }\n            int min = l[i];\n            int mini = i;\n            for(int j : set) {\n                if(l[j] < min) {\n                    min = l[j];\n                    mini = j;\n                }\n            }\n            int max = 0;\n            int mask = 0;\n            for(int j : set) {\n                l[j] -= min;\n                max = Math.max(max, l[j]);\n                mask |= 1<<l[j];\n            }\n            gs.add(new G(mini, max, mask, set.size()));\n        }\n        d = gs.size();\n        gs.sort(Comparator.comparingInt(a -> a.cnt));\n\nThere is a bug in the last statement, please help me fix it.\n\nPlease return the results in a strict JSON format as described below. Please follow these instructions carefully:\n1. Your output must include each repaired line's number (`line_number`) and the corresponding fixed code statement (`fixed_statement`).\n2. The output format must be a valid JSON array, where each element represents one repaired line, with the following structure:\n   - `\"line_number\"`: The line number of the buggy code that was repaired (integer).\n   - `\"fixed_statement\"`: The repaired statement for that specific line (string).\n\n3. The result must strictly follow this format:\n[\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    },\n    {\n        \"line_number\": int,\n        \"fixed_statement\": \"string\"\n    }\n]\n4. The repaired statement in \"fixed_statement\" must replace the corresponding line in the buggy code.\n5. You must NOT include any additional explanation or description in your response. Only return the JSON array. Do not include ```json or ``` markers in the response.\n"
    }
]