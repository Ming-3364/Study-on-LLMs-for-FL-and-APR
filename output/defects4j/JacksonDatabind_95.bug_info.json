[
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "buggy_method": {
            "method_name": "constructSpecializedType",
            "method_body": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (4) If all else fails, do the full traversal using placeholders\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            newType = _fromClass(null, subclass, tb);\n\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n    }",
            "start_line": 342,
            "end_line": 412,
            "buggy_lines": [
                355,
                366
            ]
        },
        "buggy_method_src": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n            if (baseType.isContainerType()) {\n                if (baseType.isMapLikeType()) {\n                    if ((subclass == HashMap.class)\n                            || (subclass == LinkedHashMap.class)\n                            || (subclass == EnumMap.class)\n                            || (subclass == TreeMap.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                        break;\n                    }\n                } else if (baseType.isCollectionLikeType()) {\n                    if ((subclass == ArrayList.class)\n                            || (subclass == LinkedList.class)\n                            || (subclass == HashSet.class)\n                            || (subclass == TreeSet.class)) {\n                        newType = _fromClass(null, subclass,\n                                TypeBindings.create(subclass, baseType.getContentType()));\n                        break;\n                    }\n                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                    //    but they are impl details and we basically do not care...\n                    if (rawBase == EnumSet.class) {\n                        return baseType;\n                    }\n                }\n            }\n            // (3) Sub-class does not take type parameters -- just resolve subtype\n            int typeParamCount = subclass.getTypeParameters().length;\n            if (typeParamCount == 0) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n                break;\n            }\n            // (4) If all else fails, do the full traversal using placeholders\n            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n            newType = _fromClass(null, subclass, tb);\n\n        } while (false);\n\n        // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n        //   copied as well\n        newType = newType.withHandlersFrom(baseType);\n        return newType;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames\njava.lang.NullPointerException\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1413)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1175)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1396)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1165)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1311)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1254)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:59)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:32)\n\tat com.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:536)\n\tat com.fasterxml.jackson.databind.type.TestTypeFactory.testCanonicalNames(TestTypeFactory.java:237)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "t = tf.constructFromCanonical(\"java.util.List\");\n",
        "buggy_lines_in_method": [
            14,
            25
        ],
        "buggy_statements": [
            "                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());",
            "                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     "
        ],
        "buggy_method_src_endswith_buggy_statement": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n    {\n        // simple optimization to avoid costly introspection if type-erased type does NOT differ\n        final Class<?> rawBase = baseType.getRawClass();\n        if (rawBase == subclass) {\n            return baseType;\n        }\n\n        JavaType newType;\n\n        // also: if we start from untyped, not much to save\n        do { // bogus loop to be able to break\n            if (rawBase == Object.class) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n                break;\n            }\n            if (!rawBase.isAssignableFrom(subclass)) {\n                throw new IllegalArgumentException(String.format(\n                        \"Class %s not subtype of %s\", subclass.getName(), baseType));\n            }\n            // A few special cases where we can simplify handling:\n\n            // (1) Original target type has no generics -- just resolve subtype\n            if (baseType.getBindings().isEmpty()) {\n                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     "
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java",
        "buggy_method": {
            "method_name": "constructParametricType",
            "method_body": "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }",
            "start_line": 892,
            "end_line": 899,
            "buggy_lines": [
                896
            ]
        },
        "buggy_method_src": "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);\n        }\n        return constructParametricType(parametrized, pt);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames\njava.lang.NullPointerException\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1413)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1175)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1396)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1165)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1311)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1254)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:59)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:32)\n\tat com.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:536)\n\tat com.fasterxml.jackson.databind.type.TestTypeFactory.testCanonicalNames(TestTypeFactory.java:237)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "t = tf.constructFromCanonical(\"java.util.List\");\n",
        "buggy_lines_in_method": [
            5
        ],
        "buggy_statements": [
            "            pt[i] = _fromClass(null, parameterClasses[i], null);"
        ],
        "buggy_method_src_endswith_buggy_statement": "public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n        int len = parameterClasses.length;\n        JavaType[] pt = new JavaType[len];\n        for (int i = 0; i < len; ++i) {\n            pt[i] = _fromClass(null, parameterClasses[i], null);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java",
        "buggy_method": {
            "method_name": "parseType",
            "method_body": "protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException\n    {\n        if (!tokens.hasMoreTokens()) {\n            throw _problem(tokens, \"Unexpected end-of-string\");\n        }\n        Class<?> base = findClass(tokens.nextToken(), tokens);\n\n        // either end (ok, non generic type), or generics\n        if (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n            if (\"<\".equals(token)) {\n                List<JavaType> parameterTypes = parseTypes(tokens);\n                TypeBindings b = TypeBindings.create(base, parameterTypes);\n                return _factory._fromClass(null, base, b);\n            }\n            // can be comma that separates types, or closing '>'\n            tokens.pushBack(token);\n        }\n        return _factory._fromClass(null, base, null);\n    }",
            "start_line": 40,
            "end_line": 60,
            "buggy_lines": [
                59
            ]
        },
        "buggy_method_src": "protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException\n    {\n        if (!tokens.hasMoreTokens()) {\n            throw _problem(tokens, \"Unexpected end-of-string\");\n        }\n        Class<?> base = findClass(tokens.nextToken(), tokens);\n\n        // either end (ok, non generic type), or generics\n        if (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n            if (\"<\".equals(token)) {\n                List<JavaType> parameterTypes = parseTypes(tokens);\n                TypeBindings b = TypeBindings.create(base, parameterTypes);\n                return _factory._fromClass(null, base, b);\n            }\n            // can be comma that separates types, or closing '>'\n            tokens.pushBack(token);\n        }\n        return _factory._fromClass(null, base, null);\n    }",
        "test_stack": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames\njava.lang.NullPointerException\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1413)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1175)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1396)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1165)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1311)\n\tat com.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1254)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:59)\n\tat com.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:32)\n\tat com.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:536)\n\tat com.fasterxml.jackson.databind.type.TestTypeFactory.testCanonicalNames(TestTypeFactory.java:237)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "t = tf.constructFromCanonical(\"java.util.List\");\n",
        "buggy_lines_in_method": [
            20
        ],
        "buggy_statements": [
            "        return _factory._fromClass(null, base, null);"
        ],
        "buggy_method_src_endswith_buggy_statement": "protected JavaType parseType(MyTokenizer tokens)\n        throws IllegalArgumentException\n    {\n        if (!tokens.hasMoreTokens()) {\n            throw _problem(tokens, \"Unexpected end-of-string\");\n        }\n        Class<?> base = findClass(tokens.nextToken(), tokens);\n\n        // either end (ok, non generic type), or generics\n        if (tokens.hasMoreTokens()) {\n            String token = tokens.nextToken();\n            if (\"<\".equals(token)) {\n                List<JavaType> parameterTypes = parseTypes(tokens);\n                TypeBindings b = TypeBindings.create(base, parameterTypes);\n                return _factory._fromClass(null, base, b);\n            }\n            // can be comma that separates types, or closing '>'\n            tokens.pushBack(token);\n        }\n        return _factory._fromClass(null, base, null);"
    }
]