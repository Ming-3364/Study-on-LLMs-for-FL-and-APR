[
    {
        "prompt_fl_1": {
            "doubao-pro-4k": "11",
            "qwen-turbo": "7",
            "ernie-3.5-128k": "**16**",
            "deepseek-chat": "15",
            "gpt-4o-mini": "29"
        },
        "prompt_fl_4": {
            "doubao-pro-4k": "str.append(ans - m);",
            "qwen-turbo": "str.append(ans - m);",
            "deepseek-chat": "```java\nans += (k * (k + 1)) / 2;\n```",
            "ernie-3.5-128k": "if (vis[i] == true)",
            "gpt-4o-mini": "str.append(ans - m);"
        },
        "prompt_apr_1": {
            "gpt-4o-mini": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, adj, vis);\n            ans += (k * (k + 1)) / 2;\n        }\n        str.append(ans - m).append(\"\\n\");\n    }\n    System.out.println(str);\n    sc.close();\n}\n\nprivate static int dfs(int node, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n    vis[node] = true;\n    int size = 1;\n    for (int neighbor : adj.get(node)) {\n        if (!vis[neighbor]) {\n            size += dfs(neighbor, adj, vis);\n        }\n    }\n    return size;\n}",
            "qwen-turbo": "Certainly! The issue on line [22] seems to be related to the logic of calculating the number of connected components and their sizes. The `dfs` function should correctly count the nodes in each connected component. Let's assume the `dfs` function is defined elsewhere and correctly returns the size of the connected component.\n\nHere is the complete corrected method:\n\n```java\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = 1;\n        StringBuilder str = new StringBuilder();\n        for (int xx = 0; xx < t; xx++) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                adj.add(new ArrayList<>());\n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt() - 1;\n                int b = sc.nextInt() - 1;\n                adj.get(a).add(b);\n                adj.get(b).add(a);\n            }\n            boolean[] vis = new boolean[n];\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (vis[i])\n                    continue;\n                int k = dfs(i, -1, adj, vis);\n                ans += (long) k * (k + 1) / 2;\n                // System.out.println(k + \" \" + ans);\n            }\n            str.append(ans - m).append(\"\\n\");\n        }\n        System.out.print(str);\n        sc.close();\n    }\n\n    private static int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n        vis[node] = true;\n        int count = 1;\n        for (int neighbor : adj.get(node)) {\n            if (neighbor == parent || vis[neighbor]) continue;\n            count += dfs(neighbor, node, adj, vis);\n        }\n        return count;\n    }\n}\n```\n\nChanges made:\n1. Added the `dfs` method definition to ensure the method is available.\n2. Changed the calculation of `ans` to use a cast to `long` to avoid integer overflow.\n3. Appended a newline character (`\\n`) after appending the result to the `StringBuilder`.\n4. Ensured that the `System.out.print(str);` statement prints the final result without the unnecessary `StringBuilder` object.",
            "deepseek-chat": "The bug in line [22] is related to the calculation of the number of edges in the connected component. The formula `(k * (k + 1)) / 2` is incorrect for calculating the number of edges in a connected component. The correct formula to calculate the number of edges in a connected component with `k` nodes is `(k * (k - 1)) / 2`, which represents the number of edges in a complete graph with `k` nodes.\n\nHere is the complete corrected method:\n\n```java\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, -1, adj, vis);\n            ans += (k * (k - 1)) / 2;  // Corrected formula for the number of edges in a connected component\n            // System.out.println(k + \" \" + ans);\n        }\n        str.append(ans - m);\n    }\n    System.out.println(str);\n    sc.close();\n}\n```\n\nIn this corrected version, the formula `(k * (k - 1)) / 2` is used to calculate the number of edges in a connected component with `k` nodes. This formula correctly represents the number of edges in a complete graph with `k` nodes.",
            "doubao-pro-4k": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, -1, adj, vis);\n            ans += (k * (k + 1)) / 2;\n            // System.out.println(k + \" \" + ans);\n        }\n        str.append(ans - m);\n    }\n    System.out.println(str);\n    sc.close();\n}\n\nstatic int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n    vis[node] = true;\n    int count = 1;\n    for (int child : adj.get(node)) {\n        if (child!= parent &&!vis[child]) {\n            count += dfs(child, node, adj, vis);\n        }\n    }\n    return count;\n}",
            "ernie-3.5-128k": "public static void main(String[] args) {\n\tScanner sc = new Scanner(System.in);\n\tint t = 1;\n\tStringBuilder str = new StringBuilder();\n\tfor (int xx = 0; xx < t; xx++) {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadj.add(new ArrayList<>());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tadj.get(a).add(b);\n\t\t\tadj.get(b).add(a);\n\t\t}\n\t\tboolean[] vis = new boolean[n];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (vis[i])\n\t\t\t\tcontinue;\n\t\t\tint k = dfs(i, -1, adj, vis);\n\t\t\tans += (long)k * (k - 1) / 2;  // Corrected line: Use (k * (k - 1)) / 2 instead of (k * (k + 1)) / 2\n\t\t\t// System.out.println(k + \" \" + ans);\n\t\t}\n\t\tstr.append(ans);  // Corrected: Removed \"- m\" since it seems to be an incorrect adjustment\n\t}\n\tSystem.out.println(str);\n\tsc.close();\n}\n\n// Assuming the dfs method is defined elsewhere in the code as follows:\nprivate static int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n\tvis[node] = true;\n\tint count = 1;\n\tfor (int neighbor : adj.get(node)) {\n\t\tif (!vis[neighbor] && neighbor != parent) {\n\t\t\tcount += dfs(neighbor, node, adj, vis);\n\t\t}\n\t}\n\treturn count;\n}"
        },
        "prompt_apr_2": {
            "gpt-4o-mini": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, adj, vis);  // Fix: Removed the -1 parameter\n            ans += (k * (k + 1)) / 2;\n            // System.out.println(k + \" \" + ans);\n        }\n        str.append(ans - m);\n    }\n    System.out.println(str);\n    sc.close();\n}\n\nprivate static int dfs(int node, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n    vis[node] = true;\n    int count = 1;  // Start with the current node\n    for (int neighbor : adj.get(node)) {\n        if (!vis[neighbor]) {\n            count += dfs(neighbor, adj, vis);  // Recursively count connected nodes\n        }\n    }\n    return count;\n}",
            "qwen-turbo": "Certainly! The issue with the provided code is that the `dfs` method is not defined. Additionally, the `dfs` method should be implemented to correctly count the number of nodes in each connected component. Below is the complete corrected method with the `dfs` method included:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = 1;\n        StringBuilder str = new StringBuilder();\n        for (int xx = 0; xx < t; xx++) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                adj.add(new ArrayList<>());\n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt() - 1;\n                int b = sc.nextInt() - 1;\n                adj.get(a).add(b);\n                adj.get(b).add(a);\n            }\n            boolean[] vis = new boolean[n];\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (vis[i] == true)\n                    continue;\n                int k = dfs(i, -1, adj, vis);\n                ans += (long) k * (k + 1) / 2;\n                // System.out.println(k + \" \" + ans);\n            }\n            str.append(ans - m);\n        }\n        System.out.println(str);\n        sc.close();\n    }\n\n    private static int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n        vis[node] = true;\n        int count = 1;\n        for (int neighbor : adj.get(node)) {\n            if (!vis[neighbor] && neighbor != parent) {\n                count += dfs(neighbor, node, adj, vis);\n            }\n        }\n        return count;\n    }\n}\n```\n\nIn this corrected version:\n- A `dfs` method is added to traverse the graph and count the nodes in each connected component.\n- The `dfs` method uses a recursive approach to visit all nodes in a connected component and increments the count accordingly.\n- The result of `dfs` is used to calculate the number of triangles that can be formed within each connected component.\n- The final answer is adjusted by subtracting the number of edges `m` from the total count of possible triangles.",
            "deepseek-chat": "The bug in the code is that the `dfs` method is not defined. To fix this, you need to implement the `dfs` method, which performs a Depth-First Search (DFS) traversal to count the number of nodes in a connected component. Below is the complete corrected method with the `dfs` method included:\n\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, -1, adj, vis);\n            ans += (k * (k + 1)) / 2;\n            // System.out.println(k + \" \" + ans);\n        }\n        str.append(ans - m);\n    }\n    System.out.println(str);\n    sc.close();\n}\n\nprivate static int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n    vis[node] = true;\n    int count = 1;\n    for (int neighbor : adj.get(node)) {\n        if (neighbor != parent && !vis[neighbor]) {\n            count += dfs(neighbor, node, adj, vis);\n        }\n    }\n    return count;\n}\n\nIn this corrected code, the `dfs` method is implemented to traverse the graph starting from a given node, counting the number of nodes in the connected component. The `dfs` method is called for each unvisited node in the graph, and the result is used to calculate the total number of edges in the graph. The final result is printed after subtracting the number of edges `m` from the calculated value.",
            "doubao-pro-4k": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, -1, adj, vis); // Bug here, need to implement the dfs method\n            ans += (k * (k + 1)) / 2;\n            // System.out.println(k + \" \" + ans);\n        }\n        str.append(ans - m);\n    }\n    System.out.println(str);\n    sc.close();\n}",
            "ernie-3.5-128k": "To correct the provided method, you need to ensure that the `dfs` method is defined correctly and accessible within the context where it is called. Below is the complete corrected method including the `dfs` implementation. The `dfs` method is used to perform a depth-first search on the graph to count the nodes in each connected component.\n\nHere's the corrected code:\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = 1; // You might want to read this value from input as well\n        StringBuilder str = new StringBuilder();\n        for (int xx = 0; xx < t; xx++) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < n; i++)\n                adj.add(new ArrayList<>());\n            for (int i = 0; i < m; i++) {\n                int a = sc.nextInt() - 1;\n                int b = sc.nextInt() - 1;\n                adj.get(a).add(b);\n                adj.get(b).add(a);\n            }\n            boolean[] vis = new boolean[n];\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (vis[i])\n                    continue;\n                int k = dfs(i, -1, adj, vis);\n                ans += (long) k * (k - 1) / 2; // Corrected the formula for counting pairs\n            }\n            str.append(ans).append(\"\\n\"); // Append answer for each test case on a new line\n        }\n        System.out.println(str.toString());\n        sc.close();\n    }\n\n    // Depth-First Search to count nodes in each connected component\n    private static int dfs(int node, int parent, ArrayList<ArrayList<Integer>> adj, boolean[] vis) {\n        vis[node] = true;\n        int count = 1;\n        for (int neighbor : adj.get(node)) {\n            if (!vis[neighbor] && neighbor != parent) {\n                count += dfs(neighbor, node, adj, vis);\n            }\n        }\n        return count;\n    }\n}\n\nKey changes and points to note:\n1. **DFS Method Definition**: The `dfs` method is defined outside the `main` method and is made `private static` to match the access requirements.\n2. **Counting Pairs**: The formula to count pairs in a component with `k` nodes is `(k * (k - 1)) / 2` (combinations of 2 out of `k`), not `(k * (k + 1)) / 2`.\n3. **Reading Test Cases**: The variable `t` is hard-coded to 1, but you may want to read it from input if you have multiple test cases.\n4. **Appending Answers**: Each answer for a test case is appended followed by a newline character to properly format the output.\n5. **Casting**: Added a cast to `(long)` to ensure the multiplication does not overflow before the division in the pair-counting formula.\n\nThis should fix the issue and provide the correct output."
        },
        "prompt_apr_3": {
            "qwen-turbo": "```java\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i])\n                continue;\n            int k = dfs(i, -1, adj, vis);\n```",
            "deepseek-chat": "```java\npublic static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i])\n                continue;\n            int k = dfs(i, -1, adj, vis);\n```",
            "gpt-4o-mini": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, adj, vis);\n        }",
            "doubao-pro-4k": "public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int t = 1;\n    StringBuilder str = new StringBuilder();\n    for (int xx = 0; xx < t; xx++) {\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt() - 1;\n            int b = sc.nextInt() - 1;\n            adj.get(a).add(b);\n            adj.get(b).add(a);\n        }\n        boolean[] vis = new boolean[n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (vis[i] == true)\n                continue;\n            int k = dfs(i, -1, adj, vis); // Bug here\n        }\n    }\n}",
            "ernie-3.5-128k": "public static void main(String[] args) {\n\tScanner sc = new Scanner(System.in);\n\tint t = 1;\n\tStringBuilder str = new StringBuilder();\n\tfor (int xx = 0; xx < t; xx++) {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tadj.add(new ArrayList<>());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tadj.get(a).add(b);\n\t\t\tadj.get(b).add(a);\n\t\t}\n\t\tboolean[] vis = new boolean[n];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (vis[i])\n\t\t\t\tcontinue;\n\t\t\tint k = dfs(i, -1, adj, vis);\n\t\t\tans += someFunction(k);  // Placeholder for any function using k, assuming this was the intended use"
        },
        "prompt_apr_4": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"str.append(String.valueOf(ans - m)).append(\\\"\\\\n\\\");\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"ans += (k * (k - 1)) / 2;\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"ans += (long) k * (k + 1) / 2;\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"int k = dfs(i, adj, vis);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 22,\n        \"fixed_statement\": \"if (vis[i] == false)\"\n    }\n]"
        },
        "prompt_apr_5": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 17,\n        \"fixed_statement\": \"int k = dfs(i, adj, vis);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 17,\n        \"fixed_statement\": \"int k = dfs(adj, vis, i, -1);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 16,\n        \"fixed_statement\": \"int k = dfs(i, -1, adj, vis, n);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 18,\n        \"fixed_statement\": \"int k = dfs(i, -1, adj, vis, new int[n]);\"\n    },\n    {\n        \"line_number\": 18,\n        \"fixed_statement\": \"int k = dfs(i, -1, adj, vis, new int[n]);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 18,\n        \"fixed_statement\": \"int k = dfs(i, adj, vis);\"\n    }\n]"
        },
        "prompt_apr_6": {
            "qwen-turbo": "[\n    {\n        \"line_number\": 14,\n        \"fixed_statement\": \"ans += dfs(i, -1, adj, vis);\"\n    }\n]",
            "ernie-3.5-128k": "[\n    {\n        \"line_number\": 27,\n        \"fixed_statement\": \"ans += dfs(i, -1, adj, vis);\"\n    }\n]",
            "doubao-pro-4k": "[\n    {\n        \"line_number\": 20,\n        \"fixed_statement\": \"int k = dfs(i, -1, adj, vis, str);\"\n    }\n]",
            "deepseek-chat": "[\n    {\n        \"line_number\": 23,\n        \"fixed_statement\": \"int k = dfs(i, -1, adj, vis);\"\n    }\n]",
            "gpt-4o-mini": "[\n    {\n        \"line_number\": 26,\n        \"fixed_statement\": \"int k = dfs(i, adj, vis);\"\n    }\n]"
        }
    }
]