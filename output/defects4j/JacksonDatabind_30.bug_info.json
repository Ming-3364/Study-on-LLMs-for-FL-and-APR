[
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "buggy_method": {
            "method_name": "valueToTree",
            "method_body": "@SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    }",
            "start_line": 2504,
            "end_line": 2520,
            "buggy_lines": [
                2512
            ]
        },
        "buggy_method_src": "@SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);\n            JsonParser jp = buf.asParser();\n            result = readTree(jp);\n            jp.close();\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n        return (T) result;\n    }",
        "test_stack": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965\njunit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.TestCase.assertTrue(TestCase.java:192)\n\tat com.fasterxml.jackson.databind.jsontype.TestExternalId.testBigDecimal965(TestExternalId.java:564)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n",
        "buggy_lines_in_method": [
            9
        ],
        "buggy_statements": [
            "            writeValue(buf, fromValue);"
        ],
        "buggy_method_src_endswith_buggy_statement": "@SuppressWarnings({ \"unchecked\", \"resource\" })\n    public <T extends JsonNode> T valueToTree(Object fromValue)\n        throws IllegalArgumentException\n    {\n        if (fromValue == null) return null;\n        TokenBuffer buf = new TokenBuffer(this, false);\n        JsonNode result;\n        try {\n            writeValue(buf, fromValue);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java",
        "buggy_method": {
            "method_name": "_convert",
            "method_body": "@SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
            "start_line": 3408,
            "end_line": 3455,
            "buggy_lines": [
                3431
            ]
        },
        "buggy_method_src": "@SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);\n\n            // then matching read, inlined 'readValue' with minor mods:\n            final JsonParser jp = buf.asParser();\n            Object result;\n            // ok to pass in existing feature flags; unwrapping handled by mapper\n            final DeserializationConfig deserConfig = getDeserializationConfig();\n            JsonToken t = _initForReading(jp);\n            if (t == JsonToken.VALUE_NULL) {\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);\n            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                result = null;\n            } else { // pointing to event other than null\n                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);\n                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);\n                // note: no handling of unwarpping\n                result = deser.deserialize(jp, ctxt);\n            }\n            jp.close();\n            return result;\n        } catch (IOException e) { // should not occur, no real i/o...\n            throw new IllegalArgumentException(e.getMessage(), e);\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965\njunit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.TestCase.assertTrue(TestCase.java:192)\n\tat com.fasterxml.jackson.databind.jsontype.TestExternalId.testBigDecimal965(TestExternalId.java:564)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n",
        "buggy_lines_in_method": [
            24
        ],
        "buggy_statements": [
            "            _serializerProvider(config).serializeValue(buf, fromValue);"
        ],
        "buggy_method_src_endswith_buggy_statement": "@SuppressWarnings(\"resource\")\n    protected Object _convert(Object fromValue, JavaType toValueType)\n        throws IllegalArgumentException\n    {        \n        // also, as per [Issue-11], consider case for simple cast\n        /* But with caveats: one is that while everything is Object.class, we don't\n         * want to \"optimize\" that out; and the other is that we also do not want\n         * to lose conversions of generic types.\n         */\n        Class<?> targetType = toValueType.getRawClass();\n        if (targetType != Object.class\n                && !toValueType.hasGenericTypes()\n                && targetType.isAssignableFrom(fromValue.getClass())) {\n            return fromValue;\n        }\n        \n        // Then use TokenBuffer, which is a JsonGenerator:\n        TokenBuffer buf = new TokenBuffer(this, false);\n        try {\n            // inlined 'writeValue' with minor changes:\n            // first: disable wrapping when writing\n            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n            // no need to check for closing of TokenBuffer\n            _serializerProvider(config).serializeValue(buf, fromValue);"
    },
    {
        "buggy_file": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java",
        "buggy_method": {
            "method_name": "copyCurrentEvent",
            "method_body": "@Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }",
            "start_line": 917,
            "end_line": 990,
            "buggy_lines": [
                966,
                973,
                983
            ]
        },
        "buggy_method_src": "@Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n        }\n    }",
        "test_stack": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965\njunit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.TestCase.assertTrue(TestCase.java:192)\n\tat com.fasterxml.jackson.databind.jsontype.TestExternalId.testBigDecimal965(TestExternalId.java:564)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n",
        "test_assert": "assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n",
        "buggy_lines_in_method": [
            50,
            57,
            67
        ],
        "buggy_statements": [
            "                    writeNumber(p.getDecimalValue());",
            "            }",
            "            break;"
        ],
        "buggy_method_src_endswith_buggy_statement": "@Override\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        if (_mayHaveNativeIds) {\n            _checkNativeIds(p);\n        }\n        switch (p.getCurrentToken()) {\n        case START_OBJECT:\n            writeStartObject();\n            break;\n        case END_OBJECT:\n            writeEndObject();\n            break;\n        case START_ARRAY:\n            writeStartArray();\n            break;\n        case END_ARRAY:\n            writeEndArray();\n            break;\n        case FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case VALUE_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case VALUE_NUMBER_INT:\n            switch (p.getNumberType()) {\n            case INT:\n                writeNumber(p.getIntValue());\n                break;\n            case BIG_INTEGER:\n                writeNumber(p.getBigIntegerValue());\n                break;\n            default:\n                writeNumber(p.getLongValue());\n            }\n            break;\n        case VALUE_NUMBER_FLOAT:\n                /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying\n                 *   number is already decoded into a number (in which case might as well\n                 *   access as number); or is still retained as text (in which case we\n                 *   should further defer decoding that may not need BigDecimal):\n                 */\n                switch (p.getNumberType()) {\n                case BIG_DECIMAL:\n                    writeNumber(p.getDecimalValue());\n                    break;\n                case FLOAT:\n                    writeNumber(p.getFloatValue());\n                    break;\n                default:\n                    writeNumber(p.getDoubleValue());\n            }\n            break;\n        case VALUE_TRUE:\n            writeBoolean(true);\n            break;\n        case VALUE_FALSE:\n            writeBoolean(false);\n            break;\n        case VALUE_NULL:\n            writeNull();\n            break;"
    }
]